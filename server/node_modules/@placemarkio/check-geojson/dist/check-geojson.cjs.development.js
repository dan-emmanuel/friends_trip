'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var momoa = require('@humanwhocodes/momoa');

class HintError extends Error {
  constructor(issues) {
    super();
    this.issues = []; // restore prototype chain

    const actualProto = new.target.prototype;
    Object.setPrototypeOf(this, actualProto);
    this.issues = issues;
  }

  get message() {
    return JSON.stringify(this.issues, null, 2);
  }

}

const GEOJSON_FEATURE_TYPE = /*#__PURE__*/new Set(['Feature']);
const GEOJSON_GEOMETRY_TYPES = /*#__PURE__*/new Set(['Point', 'MultiPoint', 'Polygon', 'MultiPolygon', 'LineString', 'MultiLineString', 'GeometryCollection']);
const GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION = /*#__PURE__*/new Set(['Point', 'MultiPoint', 'Polygon', 'MultiPolygon', 'LineString', 'MultiLineString']);
const GEOJSON_TYPES = /*#__PURE__*/new Set([...GEOJSON_GEOMETRY_TYPES, 'Feature', 'FeatureCollection']);

function getType(issues, node, allowedTypes) {
  if (node.type !== 'Object') {
    throw new HintError([{
      code: 'invalid_type',
      message: 'Expected an object, but found an incorrect type.',
      loc: node.loc
    }]);
  }

  const typeMember = node.members.find(member => {
    return member.name.value === 'type';
  });

  if (!typeMember) {
    throw new HintError([{
      code: 'invalid_type',
      message: 'This GeoJSON object is missing its type member.',
      loc: node.loc
    }]);
  }

  const value = typeMember.value;

  if (value.type !== 'String') {
    issues.push({
      code: 'invalid_type',
      message: 'The type member should have been a string.',
      loc: value.loc
    });
    return {};
  }

  if (!allowedTypes.has(value.value)) {
    issues.push({
      code: 'invalid_type',
      message: 'This type of GeoJSON object is not allowed here.',
      loc: value.loc
    });
    return {};
  }

  return {
    type: value.value,
    objectNode: node
  };
}

function getMemberValue(issues, node, name) {
  const member = node.members.find(member => {
    return member.name.value === name;
  });

  if (!member) {
    issues.push({
      code: 'invalid_type',
      message: `This GeoJSON object requires a ${name} member but it is missing.`,
      loc: node.loc
    });
    return null;
  }

  return member.value;
}

function getArray(issues, node) {
  if ((node == null ? void 0 : node.type) === 'Array') return node;

  if (node) {
    issues.push({
      code: 'invalid_type',
      message: 'This must be an array.',
      loc: node.loc
    });
  }

  return null;
}

function getObject(issues, node) {
  if ((node == null ? void 0 : node.type) === 'Object') return node;

  if (node) {
    issues.push({
      code: 'invalid_type',
      message: 'This must be an object.',
      loc: node.loc
    });
  }

  return null;
}

function getCoordinates(issues, node) {
  const coordinatesMember = getMemberValue(issues, node, 'coordinates');
  if (!coordinatesMember) return null;
  return getArray(issues, coordinatesMember);
}

function enforcePosition(issues, node) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;

  if (node.elements.length < 2 || node.elements.length > 3) {
    issues.push({
      code: 'invalid_type',
      message: `A position should have 2 or 3 elements - found ${node.elements.length}.`,
      loc: node.loc
    });
  }

  for (let element of node.elements) {
    if (element.type !== 'Number') {
      issues.push({
        code: 'invalid_type',
        message: 'Each element in a position must be a number.',
        loc: element.loc
      });
      return;
    }
  }
}

function checkDuplicateKeys(issues, node) {
  let keys = new Set();

  for (let {
    name: {
      value
    },
    loc
  } of node.members) {
    if (keys.has(value)) {
      issues.push({
        code: 'invalid_type',
        message: 'Duplicate properties are ambiguous in GeoJSON',
        loc: loc
      });
    }

    keys.add(value);
  }

  return node;
}

function enforceSamePosition(issues, node) {
  const first = node.elements[0];
  const last = node.elements[node.elements.length - 1];

  if (first.elements.length !== last.elements.length) {
    issues.push({
      code: 'invalid_type',
      message: 'First and last positions of a Polygon or MultiPolygon’s ring should be the same.',
      loc: first.loc
    });
    return;
  }

  for (let j = 0; j < first.elements.length; j++) {
    const firstValue = first.elements[j].value;
    const secondValue = last.elements[j].value;

    if (firstValue !== secondValue) {
      issues.push({
        code: 'invalid_type',
        message: 'First and last positions of a Polygon or MultiPolygon’s ring should be the same.',
        loc: last.elements[j].loc
      });
      return;
    }
  }
}

function getArray$1(issues, node) {
  if (node.type !== 'Array') {
    issues.push({
      code: 'invalid_type',
      message: 'Expected to find an array of positions here.',
      loc: node.loc
    });
    return null;
  }

  return node;
}

function enforcePositionArray(issues, node, kind) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;
  node = getArray$1(issues, node);
  if (!node) return;

  for (let element of node.elements) {
    if (element.type !== 'Array') {
      issues.push({
        code: 'invalid_type',
        message: 'Expected to find a position here, found another type.',
        loc: element.loc
      });
      return;
    } else {
      enforcePosition(issues, element);
    }
  }

  switch (kind) {
    case 'LineString':
      {
        if (node.elements.length < 2) {
          issues.push({
            code: 'invalid_type',
            message: 'Expected to find two or more positions here.',
            loc: node.loc
          });
        }

        break;
      }

    case 'Polygon':
      if (node.elements.length < 4) {
        issues.push({
          code: 'invalid_type',
          message: 'Expected to find four or more positions here.',
          loc: node.loc
        });
      }

      enforceSamePosition(issues, node);
      break;
  }
}
function enforcePositionArray2(issues, node, kind) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;
  node = getArray$1(issues, node);
  if (!node) return;

  for (let element of node.elements) {
    enforcePositionArray(issues, element, kind);
  }
}
function enforcePositionArray3(issues, node, kind) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;
  node = getArray$1(issues, node);
  if (!node) return;

  for (let element of node.elements) {
    enforcePositionArray2(issues, element, kind);
  }
}

function enforceBbox(issues, node) {
  const member = node.members.find(member => {
    return member.name.value === 'bbox';
  }); // bboxes are optional

  if (member === undefined) return;
  const array = getArray(issues, member.value);
  if (!array) return;

  if (!(array.elements.length === 4 || array.elements.length === 6)) {
    issues.push({
      code: 'invalid_type',
      message: 'A bbox must have 4 or 6 positions',
      loc: array.loc
    });
  }

  for (let element of array.elements) {
    if (element.type !== 'Number') {
      issues.push({
        code: 'invalid_type',
        message: 'Each element in a bbox must be a number.',
        loc: element.loc
      });
      return;
    }
  }
}

function forbidProperty(issues, member, propertiesFrom, name) {
  if (member.name.value === name) {
    issues.push({
      code: 'invalid_type',
      message: `${propertiesFrom} objects cannot contain a member named ${member.name.value}`,
      loc: member.name.loc
    });
  }
}

const FORBIDDEN_PROPERTIES = {
  Geometry: ['properties', 'geometry', 'features'],
  Feature: ['features'],
  FeatureCollection: ['properties', 'coordinates']
};
function forbidConfusingProperties(issues, node, propertiesFrom) {
  for (let member of node.members) {
    for (let property of FORBIDDEN_PROPERTIES[propertiesFrom]) {
      forbidProperty(issues, member, propertiesFrom, property);
    }
  }
}

const checkGeometryShared = (issues, node) => {
  enforceBbox(issues, node);
  forbidConfusingProperties(issues, node, 'Geometry');
};

const checkLineString = (issues, node) => {
  enforcePositionArray(issues, getCoordinates(issues, node), 'LineString');
  checkGeometryShared(issues, node);
};

const checkMultiLineString = (issues, node) => {
  enforcePositionArray2(issues, getCoordinates(issues, node), 'LineString');
  checkGeometryShared(issues, node);
};

const checkPolygon = (issues, node) => {
  enforcePositionArray2(issues, getCoordinates(issues, node), 'Polygon');
  checkGeometryShared(issues, node);
};

const checkMultiPolygon = (issues, node) => {
  enforcePositionArray3(issues, getCoordinates(issues, node), 'Polygon');
  checkGeometryShared(issues, node);
};

const checkPoint = (issues, node) => {
  enforcePosition(issues, getCoordinates(issues, node));
  checkGeometryShared(issues, node);
};

const checkMultiPoint = (issues, node) => {
  enforcePositionArray(issues, getCoordinates(issues, node));
  checkGeometryShared(issues, node);
};

const checkGeometryCollection = (issues, node) => {
  checkGeometryShared(issues, node);
  const geometriesMember = getArray(issues, getMemberValue(issues, node, 'geometries'));
  if (!geometriesMember) return;

  for (let element of geometriesMember.elements) {
    checkObject(issues, element, GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION);
  }
};

const checkFeature = (issues, node) => {
  forbidConfusingProperties(issues, node, 'Feature');
  const geometryMember = getMemberValue(issues, node, 'geometry');
  enforceBbox(issues, node);

  if ((geometryMember == null ? void 0 : geometryMember.type) !== 'Null') {
    const geometry = getObject(issues, geometryMember);
    if (geometry) checkObject(issues, geometry, GEOJSON_GEOMETRY_TYPES);
  }

  const idMember = node.members.find(member => {
    return member.name.value === 'id';
  });

  if (idMember && !(idMember.value.type === 'String' || idMember.value.type === 'Number')) {
    issues.push({
      code: 'invalid_type',
      message: `The Feature id must be a string or number.`,
      loc: idMember.loc
    });
  }

  const properties = getMemberValue(issues, node, 'properties');

  if (!properties) {
    issues.push({
      code: 'invalid_type',
      message: `The properties member is missing.`,
      loc: node.loc
    });
    return;
  }

  const {
    type
  } = properties;

  if (!(type === 'Object' || type === 'Null')) {
    issues.push({
      code: 'invalid_type',
      message: `The Feature properties member can be an object or null.`,
      loc: node.loc
    });
  }
};

const checkFeatureCollection = (issues, node) => {
  forbidConfusingProperties(issues, node, 'FeatureCollection');
  const featuresMember = getArray(issues, getMemberValue(issues, node, 'features'));
  if (!featuresMember) return;

  for (let feature of featuresMember.elements) {
    const obj = getObject(issues, feature);

    if (obj) {
      getType(issues, obj, GEOJSON_FEATURE_TYPE);
      checkFeature(issues, obj);
    }
  }
};

const CHECKERS = {
  LineString: checkLineString,
  MultiLineString: checkMultiLineString,
  Polygon: checkPolygon,
  MultiPolygon: checkMultiPolygon,
  Point: checkPoint,
  MultiPoint: checkMultiPoint,
  GeometryCollection: checkGeometryCollection,
  Feature: checkFeature,
  FeatureCollection: checkFeatureCollection
};

function checkObject(issues, node, typeSet = GEOJSON_TYPES) {
  const {
    type,
    objectNode
  } = getType(issues, node, typeSet);
  if (!(type && objectNode)) return;
  checkDuplicateKeys(issues, objectNode);
  CHECKERS[type](issues, objectNode);
}

const check = jsonStr => {
  const issues = [];
  let ast;

  try {
    ast = momoa.parse(jsonStr, {
      ranges: true
    });
  } catch (e) {
    issues.push({
      code: 'invalid_json',
      line: e.line
    });
  }

  if (ast) checkObject(issues, ast.body);
  if (issues.length || !ast) throw new HintError(issues);
  return momoa.evaluate(ast);
};

exports.HintError = HintError;
exports.check = check;
//# sourceMappingURL=check-geojson.cjs.development.js.map
